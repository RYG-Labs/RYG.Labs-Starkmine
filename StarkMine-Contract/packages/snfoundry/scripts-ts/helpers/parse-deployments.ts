import fs from "fs";
import path from "path";
import prettier from "prettier";
import { Abi, CompiledSierra } from "starknet";

// Define contract deployment data interface
interface ContractData {
  contract: string;
  address: string;
  classHash: string;
}

console.log("*** Parsing deployments...");

const TARGET_DIR = path.join(__dirname, "../../../nextjs/contracts");
const deploymentsDir = path.join(__dirname, "../../deployments");
const files = fs.readdirSync(deploymentsDir);

const generatedContractComment = `/**
 * This file is autogenerated by Scaffold-Stark.
 * You should not edit it manually or your changes might be overwritten.
 */`;

/**
 * Find contract ABI file based on contract name
 */
const findContractAbiFile = (contractName: string): string | null => {
  const targetDir = path.resolve(__dirname, "../../contracts/target/dev");
  const files = fs.readdirSync(targetDir);

  // Look for pattern like "*_ContractName.contract_class.json"
  const pattern = new RegExp(`.*_${contractName}\\.contract_class\\.json$`);
  const matchingFile = files.find((file) => pattern.test(file));

  if (!matchingFile) {
    return null;
  }

  return path.join(targetDir, matchingFile);
};

const getContractDataFromDeployments = (): Record<
  string,
  Record<string, { address: string; abi: Abi; classHash: string }>
> => {
  const allContractsData: Record<
    string,
    Record<string, { address: string; abi: Abi; classHash: string }>
  > = {};

  files.forEach((file) => {
    if (path.extname(file) === ".json" && file.endsWith("_latest.json")) {
      const filePath = path.join(deploymentsDir, file);

      // Add type assertion for the content
      const content = JSON.parse(fs.readFileSync(filePath, "utf8")) as Record<string, ContractData>;
      const chainId = path.basename(file, "_latest.json");

      Object.entries(content).forEach(([contractName, contractData]) => {
        try {
          const abiFilePath = findContractAbiFile(contractData.contract);

          if (!abiFilePath) {
            console.error(`Could not find ABI file for ${contractData.contract}`);
            return;
          }

          const abiContent = JSON.parse(
            fs.readFileSync(abiFilePath, "utf8")
          ) as CompiledSierra;

          allContractsData[chainId] = {
            ...allContractsData[chainId],
            [contractName]: {
              address: contractData.address,
              abi: abiContent.abi.filter((item) => item.type !== "l1_handler"),
              classHash: contractData.classHash,
            },
          };
        } catch (e) {
          console.error(`Error processing ${contractName}:`, e);
        }
      });
    }
  });

  return allContractsData;
};

const generateTsAbis = () => {
  const allContractsData = getContractDataFromDeployments();

  const fileContent = Object.entries(allContractsData).reduce(
    (content, [chainId, chainConfig]) => {
      // Use chainId directly as it is already a hex string
      return `${content}${chainId}:${JSON.stringify(chainConfig, null, 2)},`;
    },
    ""
  );

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }

  fs.writeFileSync(
    path.join(TARGET_DIR, "deployedContracts.ts"),
    prettier.format(
      `${generatedContractComment}\n\nconst deployedContracts = {${fileContent}} as const;\n\nexport default deployedContracts;`,
      {
        parser: "typescript",
      }
    )
  );

  console.log(
    `üìù Updated TypeScript contract definition file on ${TARGET_DIR}/deployedContracts.ts`
  );
};

generateTsAbis();
